# Código Fonte: NewEngine V3.0 (Tabelas Dinâmicas)
**Data**: 27/01/2026
**Versão**: 3.0.0
**Destaque**: Integração total da "Cirurgia de Tabelas" pós-processamento.

```csharp
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using DocumentFormat.OpenXml;
using DocumentFormat.OpenXml.Packaging;
using DocumentFormat.OpenXml.Wordprocessing;
using DocumentFormat.OpenXml.CustomProperties;

namespace WordStitcher
{
    class Program
    {
        // Estrutura para armazenar dados das tabelas dinâmicas
        private static Dictionary<string, List<string[]>> TablesData = new Dictionary<string, List<string[]>>();

        // Mapa Geográfico das Máquinas (Filtro original mantido)
        private static readonly Dictionary<string, (int Start, int End)> MachineRanges = new Dictionary<string, (int, int)>
        {
            { "BTR", (5, 138) }, { "GTR", (142, 271) }, { "DVD", (277, 440) },
            { "PET", (446, 532) }, { "CIP", (538, 648) }, { "CMX", (654, 728) },
            { "CCMX", (734, 828) }, { "PLT", (834, 928) }, { "PCK", (933, 2027) }
        };

        static void Main(string[] args)
        {
            Console.WriteLine("--- NewEngine V3.0 (One-Shot Assembly + Dynamic Tables) ---");

            if (args.Length < 1)
            {
                Console.WriteLine("Uso: NewGeradorV2.exe <caminho_do_manifesto.csv>");
                return;
            }

            string manifestPath = args[0];
            
            try
            {
                if (!File.Exists(manifestPath)) { ShowError("Manifesto nao encontrado: " + manifestPath); return; }

                // 1. Parse do Manifesto (Arquivos, Metadados e TABELAS)
                var result = ParseManifest(manifestPath);

                // 2. Definicao do Nome do Arquivo de Saida
                string pOrder = result.Metadata.GetValueOrDefault("ORDER_NUMBER", "00000000");
                string pMachine = result.Metadata.GetValueOrDefault("MACHINE_TYPE", "Machine");
                string pK = result.Metadata.GetValueOrDefault("K_NUMBER", "000000");
                
                string outputFileName = $"BA_{pOrder}_{pK}_{pMachine}_PT.docx";
                outputFileName = string.Join("", outputFileName.Split(Path.GetInvalidFileNameChars()));
                
                string fullOutputPath = Path.Combine(Path.GetDirectoryName(Path.GetFullPath(manifestPath)), outputFileName);
                if (!IsFileReady(fullOutputPath)) { ShowError("O arquivo de saida esta aberto. Feche-o."); return; }

                // 3. Filtragem Geografica de Arquivos
                var filesToProcess = FilterFilesByRange(result.Files, pMachine);
                if (filesToProcess.Count == 0) { ShowError("Nenhum arquivo selecionado."); return; }

                // 4. Montagem e Injeção (O Coração do Motor)
                StitchAndProcess(fullOutputPath, filesToProcess, result.Metadata);

                Console.WriteLine("\n[SUCESSO] Manual gerado e tabelas processadas: " + fullOutputPath);
            }
            catch (Exception ex)
            {
                ShowError("Falha critica: " + ex.Message + "\nStack: " + ex.StackTrace);
            }

            Console.WriteLine("\nProcesso finalizado. Pressione qualquer tecla...");
            Console.ReadKey(true);
        }

        static void StitchAndProcess(string outputPath, List<string> inputFiles, Dictionary<string, string> metadata)
        {
            Console.WriteLine("[INFO] Iniciando montagem do documento...");

            // 1. Criar Doc Final baseado no primeiro arquivo (Capa)
            if (File.Exists(outputPath)) File.Delete(outputPath);
            File.Copy(inputFiles[0], outputPath);

            using (WordprocessingDocument mainDoc = WordprocessingDocument.Open(outputPath, true))
            {
                MainDocumentPart mainPart = mainDoc.MainDocumentPart;
                var body = mainPart.Document.Body;

                // --- A. Empilhamento de Arquivos ---
                for (int i = 1; i < inputFiles.Count; i++)
                {
                    Console.WriteLine(" [+] Anexando: " + Path.GetFileName(inputFiles[i]));
                    
                    // Quebra de página simples entre arquivos
                    body.AppendChild(new Paragraph(new Run(new Break() { Type = BreakValues.Page })));
                    
                    AppendViaAltChunk(mainPart, inputFiles[i], "AltChunkId" + i);
                }

                // --- B. Injeção de Metadados da Capa (V8) ---
                InjectMetadata(mainDoc, metadata);

                // --- C. Processamento de Tabelas Dinâmicas (V3.0/V9) ---
                if (TablesData.Count > 0)
                {
                    Console.WriteLine("[INFO] Processando tabelas dinamicas...");
                    ProcessDynamicTables(body);
                }

                // Forçar atualização de campos ao abrir (TOC, etc.)
                var settingsPart = mainPart.DocumentSettingsPart ?? mainPart.AddNewPart<DocumentSettingsPart>();
                if (settingsPart.Settings == null) settingsPart.Settings = new Settings();
                if (settingsPart.Settings.GetFirstChild<UpdateFieldsOnOpen>() == null)
                    settingsPart.Settings.Append(new UpdateFieldsOnOpen() { Val = true });

                mainPart.Document.Save();
            }
        }

        static void ProcessDynamicTables(Body body)
        {
            var allTables = body.Descendants<Table>().ToList();
            
            foreach (var table in allTables)
            {
                // Busca o título da tabela (Alt Text)
                var tblPr = table.GetFirstChild<TableProperties>();
                string title = tblPr?.TableCaption?.Val?.Value ?? tblPr?.TableDescription?.Val?.Value;

                if (!string.IsNullOrEmpty(title) && TablesData.ContainsKey(title))
                {
                    Console.WriteLine($"  -> Tabela encontrada: '{title}'. Preenchendo dados...");
                    FillTable(table, TablesData[title]);
                }
            }
        }

        static void FillTable(Table table, List<string[]> data)
        {
            var rows = table.Elements<TableRow>().ToList();
            if (rows.Count < 1) return;

            // Linha 0 = Cabeçalho | Linha 1 = Molde
            var headerRow = rows.First();
            var templateRow = rows.Count > 1 ? rows[1] : rows[0];
            TableRow rowMolde = (TableRow)templateRow.CloneNode(true);

            // Largura alvo baseada nos dados do CSV
            int targetCols = data.Count > 0 ? data[0].Length : 0;
            if (targetCols == 0) return;

            // 1. Ajuste de Colunas do Cabeçalho
            var headerCells = headerRow.Elements<TableCell>().ToList();
            if (headerCells.Count > targetCols)
            {
                for (int i = headerCells.Count - 1; i >= targetCols; i--) headerRow.RemoveChild(headerCells[i]);
            }

            // 2. Limpeza de linhas de dados antigas
            foreach (var row in rows.Skip(1).ToList()) table.RemoveChild(row);

            // 3. Injeção de Dados
            foreach (var rowData in data)
            {
                TableRow newRow = (TableRow)rowMolde.CloneNode(true);
                var cells = newRow.Elements<TableCell>().ToList();

                // Ajuste de colunas na linha de dados
                if (cells.Count > targetCols)
                {
                    for (int i = cells.Count - 1; i >= targetCols; i--) newRow.RemoveChild(cells[i]);
                }

                var finalCells = newRow.Elements<TableCell>().ToList();
                for (int i = 0; i < finalCells.Count; i++)
                {
                    var cell = finalCells[i];
                    string textValue = i < rowData.Length ? rowData[i] : "";

                    // Tenta preservar estilo do Run original
                    var textElement = cell.Descendants<Text>().FirstOrDefault();
                    if (textElement != null)
                    {
                        textElement.Text = textValue;
                        foreach (var et in cell.Descendants<Text>().Skip(1).ToList()) et.Remove();
                    }
                    else
                    {
                        var p = cell.Elements<Paragraph>().FirstOrDefault() ?? cell.AppendChild(new Paragraph());
                        var r = p.Elements<Run>().FirstOrDefault() ?? p.AppendChild(new Run());
                        r.AppendChild(new Text(textValue));
                    }
                }
                table.AppendChild(newRow);
            }
        }

        static void InjectMetadata(WordprocessingDocument mainDoc, Dictionary<string, string> metadata)
        {
            var customPropsPart = mainDoc.CustomFilePropertiesPart ?? mainDoc.AddCustomFilePropertiesPart();
            if (customPropsPart.Properties == null) customPropsPart.Properties = new Properties();

            var map = new Dictionary<string, string>
            {
                { "SAP_NUMBER", "MachineNumber" },
                { "ORDER_NUMBER", "Order" },
                { "REVISION", "Revision" },
                { "YEAR", "MachineYear" }
            };

            foreach (var kvp in map)
                if (metadata.ContainsKey(kvp.Key)) UpsertProperty(customPropsPart.Properties, kvp.Value, metadata[kvp.Key]);

            // Nome Completo da Máquina (Especial V8)
            if (metadata.ContainsKey("MACHINE_NAME_FULL"))
            {
                string fullName = metadata["MACHINE_NAME_FULL"];
                UpsertProperty(customPropsPart.Properties, "MachineType", fullName);
                UpsertProperty(customPropsPart.Properties, "MachineModel", fullName);
            }
        }

        static (Dictionary<string, string> Metadata, List<(int Line, string Path)> Files) ParseManifest(string manifestPath)
        {
            var files = new List<(int, string)>();
            var metadata = new Dictionary<string, string>();
            string manifestDir = Path.GetDirectoryName(Path.GetFullPath(manifestPath));
            string configBaRoot = FindConfigBaRoot(manifestDir);

            foreach (var line in File.ReadAllLines(manifestPath, Encoding.UTF8))
            {
                var parts = line.Split(';');
                if (parts.Length < 3) continue;

                string category = parts[0].Trim().ToUpper();
                string key = parts[1].Trim();
                string val = parts[2].Trim();

                switch (category)
                {
                    case "META":
                        metadata[key.ToUpper()] = val;
                        break;
                    case "FILE":
                        int ln = 0; int.TryParse(key, out ln);
                        string path = SanitizePath(val, configBaRoot);
                        if (File.Exists(path)) files.Add((ln, path));
                        break;
                    case "TABLE_ROW":
                        // Formato: TABLE_ROW;NomeTabela;Col1;Col2;Col3...
                        if (!TablesData.ContainsKey(key)) TablesData[key] = new List<string[]>();
                        TablesData[key].Add(parts.Skip(2).ToArray());
                        break;
                }
            }
            return (metadata, files);
        }

        // ---

        static void UpsertProperty(Properties props, string propName, string propValue)
        {
            var prop = props.Cast<CustomDocumentProperty>().FirstOrDefault(p => p.Name.Value == propName);
            if (prop != null)
            {
                var vpw = prop.GetFirstChild<DocumentFormat.OpenXml.VariantTypes.VTLPWSTR>();
                if (vpw != null) vpw.Text = propValue;
            }
            else
            {
                var newProp = new CustomDocumentProperty { FormatId = "{D5CDD505-2E9C-101B-9397-08002B2CF9AE}", Name = propName };
                int maxPid = props.Cast<CustomDocumentProperty>().Select(p => p.PropertyId?.Value ?? 1).DefaultIfEmpty(1).Max();
                newProp.PropertyId = maxPid + 1;
                newProp.AppendChild(new DocumentFormat.OpenXml.VariantTypes.VTLPWSTR(propValue));
                props.AppendChild(newProp);
            }
        }

        static void AppendViaAltChunk(MainDocumentPart mainPart, string filePath, string chunkId)
        {
            AlternativeFormatImportPart chunk = mainPart.AddAlternativeFormatImportPart(AlternativeFormatImportPartType.WordprocessingML, chunkId);
            using (FileStream fs = File.Open(filePath, FileMode.Open, FileAccess.Read)) chunk.FeedData(fs);
            mainPart.Document.Body.AppendChild(new AltChunk { Id = chunkId });
        }

        static List<string> FilterFilesByRange(List<(int Line, string Path)> rawFiles, string machineType)
        {
            string type = machineType.Split(' ')[0].ToUpper().Trim();
            if (!MachineRanges.ContainsKey(type)) return rawFiles.Select(f => f.Path).ToList();
            var r = MachineRanges[type];
            return rawFiles.Where(x => x.Line >= r.Start && x.Line <= r.End).Select(x => x.Path).ToList();
        }

        static string SanitizePath(string rawPath, string rootPath)
        {
            string clean = rawPath.Replace('/', Path.DirectorySeparatorChar).Replace('\', Path.DirectorySeparatorChar);
            if (clean.Contains(":")) clean = clean.Substring(clean.IndexOf("Config_BA", StringComparison.OrdinalIgnoreCase));
            else if (clean.StartsWith("Config_BA", StringComparison.OrdinalIgnoreCase)) { } 
            else clean = Path.Combine("Config_BA", clean);
            
            return Path.Combine(Directory.GetParent(rootPath).FullName, clean);
        }

        static string FindConfigBaRoot(string startDir)
        {
            DirectoryInfo dir = new DirectoryInfo(startDir);
            while (dir != null) {
                if (dir.Name.Equals("Config_BA", StringComparison.OrdinalIgnoreCase)) return dir.FullName;
                dir = dir.Parent;
            }
            return startDir;
        }

        static void ShowError(string msg) { Console.ForegroundColor = ConsoleColor.Red; Console.WriteLine("\n[ERRO] " + msg); Console.ResetColor(); }
        static bool IsFileReady(string f) { try { if (File.Exists(f)) using (File.Open(f, FileMode.Open, FileAccess.Read, FileShare.None)) { } return true; } catch { return false; } }
    }
}
```