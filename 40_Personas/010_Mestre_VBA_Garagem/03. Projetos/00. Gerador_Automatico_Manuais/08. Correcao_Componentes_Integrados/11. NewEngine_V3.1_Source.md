# Código Fonte: NewEngine V3.1 (Restauração + Tabela Pré-Processada)
**Data**: 27/01/2026
**Correção**: Restaurada a lógica de layout/seções da V2.1 que foi perdida. Implementado preenchimento de tabelas via Pré-Processamento (antes do AltChunk) para evitar corrupção e garantir que tabelas em anexos sejam encontradas.

```csharp
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using DocumentFormat.OpenXml;
using DocumentFormat.OpenXml.Packaging;
using DocumentFormat.OpenXml.Wordprocessing;
using DocumentFormat.OpenXml.CustomProperties;
using DocumentFormat.OpenXml.VariantTypes;

namespace WordStitcher
{
    class Program
    {
        // Estrutura para armazenar dados das tabelas dinâmicas
        private static Dictionary<string, List<string[]>> TablesData = new Dictionary<string, List<string[]>>();

        // Mapa Geográfico das Máquinas
        private static readonly Dictionary<string, (int Start, int End)> MachineRanges = new Dictionary<string, (int, int)>
        {
            { "BTR", (5, 138) }, { "GTR", (142, 271) }, { "DVD", (277, 440) },
            { "PET", (446, 532) }, { "CIP", (538, 648) }, { "CMX", (654, 728) },
            { "CCMX", (734, 828) }, { "PLT", (834, 928) }, { "PCK", (933, 2027) }
        };

        static void Main(string[] args)
        {
            Console.WriteLine("--- NewEngine V3.1 (Layout Restore + Pre-Process Tables) ---");

            if (args.Length < 1)
            {
                Console.WriteLine("Uso: NewGeradorV2.exe <caminho_do_manifesto.csv>");
                return;
            }

            string manifestPath = args[0];
            List<string> tempFilesCreated = new List<string>(); // Para limpeza no final
            
            try
            {
                if (!File.Exists(manifestPath)) { ShowError("Manifesto nao encontrado: " + manifestPath); return; }

                var result = ParseManifest(manifestPath);

                string pOrder = result.Metadata.GetValueOrDefault("ORDER_NUMBER", "00000000");
                string pMachine = result.Metadata.GetValueOrDefault("MACHINE_TYPE", "Machine");
                string pK = result.Metadata.GetValueOrDefault("K_NUMBER", "000000");
                if (pK == "000000") pK = result.Metadata.Keys.FirstOrDefault(k => k.StartsWith("K_") || k.StartsWith("K-")) ?? "000000";
                if (pK != "000000" && result.Metadata.ContainsKey(pK)) pK = result.Metadata[pK];

                string outputFileName = $"BA_{pOrder}_{pK}_{pMachine}_PT.docx";
                outputFileName = string.Join("", outputFileName.Split(Path.GetInvalidFileNameChars()));
                
                Console.WriteLine($"[CONFIG] Saida: {outputFileName}");

                string fullOutputPath = Path.Combine(Path.GetDirectoryName(Path.GetFullPath(manifestPath)), outputFileName);
                if (!IsFileReady(fullOutputPath)) { ShowError("O arquivo de saida esta aberto. Feche-o."); return; }

                var filesToProcess = FilterFilesByRange(result.Files, pMachine);
                if (filesToProcess.Count == 0) { ShowError("Nenhum arquivo valido."); return; }

                // --- NOVO V3.1: Pré-Processamento de Tabelas ---
                // Se tivermos tabelas para preencher, criamos cópias temporárias dos arquivos afetados
                // Isso evita o problema do AltChunk e não estraga os originais.
                if (TablesData.Count > 0)
                {
                    Console.WriteLine("[INFO] Pre-processando arquivos para injecao de tabelas...");
                    filesToProcess = PreProcessFiles(filesToProcess, tempFilesCreated);
                }

                // --- Motor V2.1 Restaurado (StitchDocuments) ---
                StitchDocuments(fullOutputPath, filesToProcess, result.Metadata);

                Console.WriteLine("\n[SUCESSO] Manual gerado: " + fullOutputPath);
            }
            catch (Exception ex)
            {
                ShowError("Falha critica: " + ex.Message + "\nStack: " + ex.StackTrace);
            }
            finally
            {
                // Limpeza de temporários
                foreach (var tmp in tempFilesCreated)
                {
                    try { if (File.Exists(tmp)) File.Delete(tmp); } catch { }
                }
            }

            Console.WriteLine("\nProcesso finalizado. Pressione qualquer tecla...");
            // Console.ReadKey(true); // Comentado para automação
        }

        // --- LÓGICA DE PRÉ-PROCESSAMENTO (V3.1) ---
        static List<string> PreProcessFiles(List<string> originalFiles, List<string> tempTracker)
        {
            var newFileList = new List<string>();
            string tempDir = Path.GetTempPath();

            foreach (var file in originalFiles)
            {
                bool modified = false;
                string workingFile = file;

                // Verificação rápida: Só abrimos o arquivo se ele for candidato a ter tabela
                // (Otimização: Poderíamos checar o nome do arquivo, mas vamos abrir todos por segurança)
                // Para não pesar, copiamos para temp apenas se detectarmos tabelas no XML dele.
                
                try
                {
                    // Cria cópia temp para inspecionar/editar
                    string tmpFile = Path.Combine(tempDir, "tmp_" + Guid.NewGuid() + ".docx");
                    File.Copy(file, tmpFile, true);
                    
                    using (WordprocessingDocument doc = WordprocessingDocument.Open(tmpFile, true))
                    {
                        var body = doc.MainDocumentPart.Document.Body;
                        var tables = body.Descendants<Table>().ToList();
                        
                        foreach (var tbl in tables)
                        {
                            var tblPr = tbl.GetFirstChild<TableProperties>();
                            string title = tblPr?.TableCaption?.Val?.Value ?? tblPr?.TableDescription?.Val?.Value;

                            if (!string.IsNullOrEmpty(title) && TablesData.ContainsKey(title))
                            {
                                Console.WriteLine($"  -> Tabela '{title}' encontrada em {Path.GetFileName(file)}. Preenchendo...");
                                FillTable(tbl, TablesData[title]);
                                modified = true;
                            }
                        }

                        if (modified) doc.MainDocumentPart.Document.Save();
                    }

                    if (modified)
                    {
                        newFileList.Add(tmpFile);
                        tempTracker.Add(tmpFile);
                    }
                    else
                    {
                        File.Delete(tmpFile); // Não precisava
                        newFileList.Add(file); // Usa original
                    }
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"[AVISO] Falha ao processar {Path.GetFileName(file)}: {ex.Message}. Usando original.");
                    newFileList.Add(file);
                }
            }
            return newFileList;
        }

        // --- LÓGICA DE PREENCHIMENTO (Validada na POC) ---
        static void FillTable(Table table, List<string[]> data)
        {
            var rows = table.Elements<TableRow>().ToList();
            if (rows.Count < 1) return;

            var headerRow = rows.First();
            var templateRow = rows.Count > 1 ? rows[1] : rows[0];
            TableRow rowMolde = (TableRow)templateRow.CloneNode(true);

            int targetCols = data.Count > 0 ? data[0].Length : 0;
            if (targetCols == 0) return;

            // Ajuste Header
            var headerCells = headerRow.Elements<TableCell>().ToList();
            if (headerCells.Count > targetCols)
                for (int i = headerCells.Count - 1; i >= targetCols; i--) headerRow.RemoveChild(headerCells[i]);

            // Limpa dados antigos
            foreach (var row in rows.Skip(1).ToList()) table.RemoveChild(row);

            // Preenche
            foreach (var rowData in data)
            {
                TableRow newRow = (TableRow)rowMolde.CloneNode(true);
                var cells = newRow.Elements<TableCell>().ToList();

                if (cells.Count > targetCols)
                    for (int i = cells.Count - 1; i >= targetCols; i--) newRow.RemoveChild(cells[i]);

                var finalCells = newRow.Elements<TableCell>().ToList();
                for (int i = 0; i < finalCells.Count; i++)
                {
                    var cell = finalCells[i];
                    string textValue = i < rowData.Length ? rowData[i] : "";

                    var textElement = cell.Descendants<Text>().FirstOrDefault();
                    if (textElement != null)
                    {
                        textElement.Text = textValue;
                        foreach (var et in cell.Descendants<Text>().Skip(1).ToList()) et.Remove();
                    }
                    else
                    {
                        var p = cell.Elements<Paragraph>().FirstOrDefault() ?? cell.AppendChild(new Paragraph());
                        var r = p.Elements<Run>().FirstOrDefault() ?? p.AppendChild(new Run());
                        r.AppendChild(new Text(textValue));
                    }
                }
                table.AppendChild(newRow);
            }
        }

        // --- MOTOR RESTAURADO (V2.1 Logic) ---
        static void StitchDocuments(string outputPath, List<string> inputFiles, Dictionary<string, string> metadata)
        {
            Console.WriteLine("[INFO] Iniciando empilhamento Hibrido (V2.1 Restore)...");

            // 1. Captura layout do Manual Padrao (manual.dotm)
            string manualLayoutXml = null;
            try {
                string templatePath = FindTemplate(inputFiles[0]);
                if (templatePath != null && File.Exists(templatePath)) {
                    using (var doc = WordprocessingDocument.Open(templatePath, false)) {
                        var sectPr = doc.MainDocumentPart.Document.Body.Elements<SectionProperties>().LastOrDefault();
                        if (sectPr != null) manualLayoutXml = sectPr.OuterXml;
                    }
                }
            } catch { }

            // 2. Construcao
            if (File.Exists(outputPath)) File.Delete(outputPath);
            File.Copy(inputFiles[0], outputPath);

            using (WordprocessingDocument mainDoc = WordprocessingDocument.Open(outputPath, true))
            {
                MainDocumentPart mainPart = mainDoc.MainDocumentPart;
                var body = mainPart.Document.Body;

                // Isolamento da Capa
                var coverSectPr = body.Elements<SectionProperties>().LastOrDefault();
                string coverSectXml = coverSectPr?.OuterXml;
                if (coverSectPr != null) coverSectPr.Remove();

                for (int i = 1; i < inputFiles.Count; i++)
                {
                    Console.WriteLine(" [+] Anexando: " + Path.GetFileName(inputFiles[i]));
                    Paragraph separator;

                    if (i == 1)
                    {
                        // Muralha da Capa (Restaura layout original da capa aqui)
                        SectionProperties breakSectPr = !string.IsNullOrEmpty(coverSectXml) 
                            ? new SectionProperties(coverSectXml) : new SectionProperties();
                        
                        var sType = breakSectPr.GetFirstChild<SectionType>();
                        if (sType == null) breakSectPr.AppendChild(new SectionType() { Val = SectionMarkValues.NextPage });
                        else sType.Val = SectionMarkValues.NextPage;

                        separator = new Paragraph(new ParagraphProperties(breakSectPr));
                    }
                    else
                    {
                        separator = new Paragraph(new Run(new Break() { Type = BreakValues.Page }));
                    }

                    body.AppendChild(separator);
                    AppendViaAltChunk(mainPart, inputFiles[i], "AltChunkId" + i);
                }

                // Aplica Lei do Manual (Layout final)
                if (!string.IsNullOrEmpty(manualLayoutXml))
                {
                    body.AppendChild(new SectionProperties(manualLayoutXml));
                }

                InjectMetadata(mainDoc, metadata);

                // Update Fields
                var settingsPart = mainPart.DocumentSettingsPart ?? mainPart.AddNewPart<DocumentSettingsPart>();
                if (settingsPart.Settings == null) settingsPart.Settings = new Settings();
                if (settingsPart.Settings.GetFirstChild<UpdateFieldsOnOpen>() == null)
                    settingsPart.Settings.Append(new UpdateFieldsOnOpen() { Val = true });

                mainPart.Document.Save();
            }
        }

        static void InjectMetadata(WordprocessingDocument mainDoc, Dictionary<string, string> metadata)
        {
            var customPropsPart = mainDoc.CustomFilePropertiesPart;
            if (customPropsPart == null) { customPropsPart = mainDoc.AddCustomFilePropertiesPart(); customPropsPart.Properties = new Properties(); }

            var map = new Dictionary<string, string> {
                { "MACHINE_TYPE", "MachineType" }, { "SAP_NUMBER", "MachineNumber" },
                { "ORDER_NUMBER", "Order" }, { "REVISION", "Revision" }, { "YEAR", "MachineYear" }
            };

            foreach (var kvp in map) if (metadata.ContainsKey(kvp.Key)) UpsertProperty(customPropsPart.Properties, kvp.Value, metadata[kvp.Key]);

            if (metadata.ContainsKey("MACHINE_NAME_FULL")) {
                string fn = metadata["MACHINE_NAME_FULL"];
                UpsertProperty(customPropsPart.Properties, "MachineType", fn);
                UpsertProperty(customPropsPart.Properties, "MachineModel", fn);
            }
        }

        static void UpsertProperty(Properties props, string propName, string propValue)
        {
            var prop = props.Cast<CustomDocumentProperty>().FirstOrDefault(p => p.Name.Value == propName);
            if (prop != null) {
                var vpw = prop.GetFirstChild<VTLPWSTR>();
                if (vpw != null) vpw.Text = propValue;
                else { prop.RemoveAllChildren(); prop.AppendChild(new VTLPWSTR(propValue)); }
            } else {
                var newProp = new CustomDocumentProperty { FormatId = "{D5CDD505-2E9C-101B-9397-08002B2CF9AE}", Name = propName };
                int maxPid = props.Cast<CustomDocumentProperty>().Select(p => p.PropertyId?.Value ?? 1).DefaultIfEmpty(1).Max();
                newProp.PropertyId = maxPid + 1;
                newProp.AppendChild(new VTLPWSTR(propValue));
                props.AppendChild(newProp);
            }
        }

        static string FindTemplate(string refFile)
        {
            string startDir = Path.GetDirectoryName(Path.GetFullPath(refFile));
            DirectoryInfo dir = new DirectoryInfo(startDir);
            while (dir != null) {
                string tp = Path.Combine(dir.FullName, "manual.dotm");
                if (File.Exists(tp)) return tp;
                if (dir.Name.Equals("Config_BA", StringComparison.OrdinalIgnoreCase)) break;
                dir = dir.Parent;
            }
            return null;
        }

        static void AppendViaAltChunk(MainDocumentPart mainPart, string filePath, string chunkId)
        {
            AlternativeFormatImportPart chunk = mainPart.AddAlternativeFormatImportPart(AlternativeFormatImportPartType.WordprocessingML, chunkId);
            using (FileStream fs = File.Open(filePath, FileMode.Open, FileAccess.Read)) chunk.FeedData(fs);
            mainPart.Document.Body.AppendChild(new AltChunk { Id = chunkId });
        }

        static List<string> FilterFilesByRange(List<(int Line, string Path)> rawFiles, string machineType)
        {
            string type = machineType.Split(' ')[0].ToUpper().Trim();
            if (!MachineRanges.ContainsKey(type)) return rawFiles.Select(f => f.Path).ToList();
            var r = MachineRanges[type];
            return rawFiles.Where(x => x.Line >= r.Start && x.Line <= r.End).Select(x => x.Path).ToList();
        }

        static (Dictionary<string, string> Metadata, List<(int Line, string Path)> Files) ParseManifest(string manifestPath)
        {
            var files = new List<(int, string)>();
            var metadata = new Dictionary<string, string>();
            string manifestDir = Path.GetDirectoryName(Path.GetFullPath(manifestPath));
            string configBaRoot = FindConfigBaRoot(manifestDir);

            foreach (var line in File.ReadAllLines(manifestPath, Encoding.UTF8))
            {
                var parts = line.Split(';');
                if (parts.Length < 3) continue;
                string cat = parts[0].Trim().ToUpper();
                string key = parts[1].Trim();
                string val = parts[2].Trim();

                if (cat == "META") metadata[key.ToUpper()] = val;
                else if (cat == "FILE") {
                    int ln = 0; int.TryParse(key, out ln);
                    string path = SanitizePath(val, configBaRoot);
                    if (File.Exists(path)) files.Add((ln, path));
                }
                else if (cat == "TABLE_ROW") {
                    if (!TablesData.ContainsKey(key)) TablesData[key] = new List<string[]>();
                    TablesData[key].Add(parts.Skip(2).ToArray());
                }
            }
            return (metadata, files);
        }

        static string SanitizePath(string rawPath, string rootPath)
        {
            string clean = rawPath.Replace('/', Path.DirectorySeparatorChar).Replace('\\', Path.DirectorySeparatorChar);
            if (clean.Contains(":")) clean = clean.Substring(clean.IndexOf("Config_BA", StringComparison.OrdinalIgnoreCase));
            else if (clean.StartsWith("Config_BA", StringComparison.OrdinalIgnoreCase)) { } 
            else clean = Path.Combine("Config_BA", clean);
            return Path.Combine(Directory.GetParent(rootPath).FullName, clean);
        }

        static string FindConfigBaRoot(string startDir)
        {
            DirectoryInfo dir = new DirectoryInfo(startDir);
            while (dir != null) {
                if (dir.Name.Equals("Config_BA", StringComparison.OrdinalIgnoreCase)) return dir.FullName;
                dir = dir.Parent;
            }
            return startDir;
        }

        static void ShowError(string msg) { Console.ForegroundColor = ConsoleColor.Red; Console.WriteLine("\n[ERRO] " + msg); Console.ResetColor(); }
        static bool IsFileReady(string f) { try { if (File.Exists(f)) using (File.Open(f, FileMode.Open, FileAccess.Read, FileShare.None)) { } return true; } catch { return false; } }
    }
}
```