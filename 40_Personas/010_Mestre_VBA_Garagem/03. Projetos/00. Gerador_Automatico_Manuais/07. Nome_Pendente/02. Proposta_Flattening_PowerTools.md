# Proposta de Engenharia V3: Integração do OpenXmlPowerTools (O Fim dos AltChunks)

**Status Atual**: A engine `WordStitcher` usa `AlternativeFormatImportPart` (AltChunk) para concatenar arquivos. Isso cria um documento "Container" que é invisível para parsers e instável em numeração até ser renderizado pelo Word.

**Objetivo**: Implementar o "Flattening" real durante a geração, fundindo os XMLs dos módulos em um único `document.xml` estruturado.

## 1. Nova Dependência
Necessário adicionar ao projeto `.csproj`:
```xml
<PackageReference Include="OpenXmlPowerTools" Version="4.5.3.2" />
<!-- Dependendo da versão do .NET, pode precisar de System.IO.Packaging ou System.Management.Automation -->
```

## 2. Refatoração do `StitchDocuments`

### Lógica Atual (V2)
1. Copia Capa para Output.
2. Abre Output.
3. Para cada arquivo na lista:
   - Cria `AltChunk`.
   - Anexa referência ao final do Body.

### Lógica Proposta (V3)
1. Carregar Capa como `WmlDocument` (Objeto em memória do PowerTools).
2. Carregar todos os Módulos como lista de `Source`.
3. Usar `DocumentBuilder.BuildDocument` para criar um novo `WmlDocument` fundido.
   - **Vantagem**: O `DocumentBuilder` resolve conflitos de estilos e `abstractNumId` automaticamente.
4. Salvar o `WmlDocument` fundido no disco.
5. Reabrir com `WordprocessingDocument` (OpenXML SDK padrão) apenas para injetar os Metadados (Propriedades Customizadas), já que o PowerTools foca em conteúdo.

## 3. Snippet do Novo Core

```csharp
using OpenXmlPowerTools; // Novo namespace

static void StitchDocuments(string outputPath, List<string> inputFiles, Dictionary<string, string> metadata)
{
    Console.WriteLine("[INFO] Iniciando fusão via PowerTools...");

    // 1. Preparar Fontes
    List<Source> sources = new List<Source>();
    
    // Adiciona Capa (com opção de manter ou descartar seções)
    sources.Add(new Source(new WmlDocument(inputFiles[0]), true)); 

    // Adiciona Módulos
    for (int i = 1; i < inputFiles.Count; i++)
    {
        // 'true' no segundo parâmetro diz para manter as quebras de seção do original
        // Podemos setar para 'false' se quisermos forçar o layout da Capa
        sources.Add(new Source(new WmlDocument(inputFiles[i]), true));
    }

    // 2. Construir (Flattening Real)
    // Isso funde styles.xml, numbering.xml e document.xml
    WmlDocument stitchedDoc = DocumentBuilder.BuildDocument(sources);
    
    // 3. Salvar
    stitchedDoc.SaveAs(outputPath);

    // 4. Pós-Processamento (Metadados) - Mantido igual
    using (WordprocessingDocument mainDoc = WordprocessingDocument.Open(outputPath, true))
    {
        InjectMetadata(mainDoc, metadata);
        // ... update fields ...
        mainDoc.MainDocumentPart.Document.Save();
    }
}
```

## 4. Riscos e Mitigação
*   **Dependência de DLL**: PowerTools não é nativo. Precisamos garantir que o `nuget restore` funcione na build.
*   **Performance**: Carregar tudo em memória (`WmlDocument`) é mais pesado que streams de `AltChunk`. Para manuais gigantes (500MB+), pode dar `OutOfMemory`. 
    *   *Mitigação*: Monitorar consumo. Se explodir, voltamos ao AltChunk apenas para casos extremos.

## 5. Próximos Passos
1. Atualizar `NewGerador.csproj`.
2. Substituir `Program.cs`.
3. Rodar `dotnet build`.
4. Testar geração.
