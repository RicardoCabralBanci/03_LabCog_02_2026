```
# -*- coding: utf-8 -*-
import os
import pathlib
import re
import frontmatter
import logging
import shutil
from google import genai
from google.genai import types
import time
from datetime import datetime # Para nomear o arquivo de resumo

# --- Configuração Inicial ---
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
VAULT_PATH = pathlib.Path(r"C:\Lab_Cognitivo_Script\Obsidian_S9_Fe")
NOTE_EXTENSIONS = ['.md']
CREATE_BACKUP = True
SUMMARY_FOLDER_RELATIVE_PATH = "13. AI Notes"
SUMMARY_FILENAME_PREFIX = "Resumo_IA_"
GUIDANCE_NOTE_RELATIVE_PATH = "Config/Instrucoes_Link_IA.md" # Não usado para resumo

# --- Configuração da API Gemini ---
# ####################################################################
# ### ATENÇÃO! API KEY HARDCODED ABAIXO!                           ###
# ### ... (Avisos de segurança mantidos) ...                       ###
# ####################################################################
HARDCODED_API_KEY = "AIzaSyDWG30FYAUc6XyVCv71vnR50pjWF-aN7i8" # <--- CHAVE INSERIDA DIRETAMENTE!

# Instancia o cliente da API
client: genai.Client | None = None
# ... (Lógica de inicialização do cliente mantida como v14) ...
if not HARDCODED_API_KEY or HARDCODED_API_KEY == "SUA_CHAVE_API_REAL_AQUI":
     logging.error("### ERRO CRÍTICO: API Key está vazia ou não foi substituída! ###")
     client = None
else:
    try:
        client = genai.Client(api_key=HARDCODED_API_KEY)
        client.models.list() # Verifica a autenticação
        logging.info("Cliente da API Gemini inicializado com sucesso (usando chave HARDCODED - NÃO SEGURO!).")
    except Exception as e:
        logging.error(f"Erro CRÍTICO ao inicializar o cliente da API Gemini com a chave fornecida: {e}.")
        client = None

# Modelo Gemini a ser usado
GEMINI_MODEL_NAME = "models/gemini-1.5-pro" # Revertido para 1.5 Pro após falhas com outros

# --- Funções Auxiliares ---

def find_notes(vault_dir: pathlib.Path) -> list[pathlib.Path]:
    """Encontra todos os arquivos de nota únicos no vault, ignorando pastas específicas."""
    # ... (código inalterado da v19) ...
    logging.info(f"Procurando por notas em: {vault_dir}")
    if not vault_dir.is_dir():
        logging.error(f"O caminho especificado não é um diretório válido: {vault_dir}")
        return []
    note_files = []
    processed_inodes = set()
    ignore_paths = []
    if SUMMARY_FOLDER_RELATIVE_PATH:
        summary_path = (vault_dir / SUMMARY_FOLDER_RELATIVE_PATH).resolve()
        ignore_paths.append(summary_path)
    if GUIDANCE_NOTE_RELATIVE_PATH:
        guidance_path = (vault_dir / GUIDANCE_NOTE_RELATIVE_PATH).resolve()
        ignore_paths.append(guidance_path)

    for item in vault_dir.rglob('*'):
        try:
            resolved_item = item.resolve()
            is_ignored = False
            for ignored_path in ignore_paths:
                try:
                    if resolved_item == ignored_path or ignored_path in resolved_item.parents:
                        is_ignored = True
                        break
                except Exception as e_rel:
                     logging.debug(f"Erro ao checar parentesco de ignore path para {item}: {e_rel}")
            if is_ignored:
                 continue

            if item.is_file() and item.suffix.lower() in NOTE_EXTENSIONS:
                try:
                    inode = item.stat().st_ino
                    if inode not in processed_inodes:
                        note_files.append(item)
                        processed_inodes.add(inode)
                    else:
                        logging.debug(f"Arquivo já processado (possivelmente link simbólico): {item}")
                except FileNotFoundError:
                     logging.warning(f"Arquivo desapareceu antes do stat(): {item}")
                except OSError as e_stat:
                    logging.warning(f"Não foi possível obter stat() do arquivo {item}: {e_stat}")
        except OSError as e:
            logging.warning(f"Não foi possível acessar o item {item}: {e}")
        except Exception as e:
            logging.error(f"Erro inesperado ao processar o item {item}: {e}")
    logging.info(f"Encontradas {len(note_files)} notas únicas para análise (fora das pastas ignoradas).")
    return note_files


def read_note_content(note_path: pathlib.Path, read_full_content=False) -> tuple[dict, str | None] | tuple[None, None]:
    """Lê o conteúdo e frontmatter de uma nota."""
    # ... (código inalterado da v19) ...
    try:
        post = frontmatter.load(note_path, encoding='utf-8')
        content = post.content if read_full_content else None
        return post.metadata, content
    except FileNotFoundError:
        logging.error(f"Erro: Arquivo não encontrado {note_path}")
        return None, None
    except UnicodeDecodeError:
        logging.warning(f"Erro de decodificação UTF-8 no arquivo {note_path}. Tentando com latin-1...")
        try:
            post = frontmatter.load(note_path, encoding='latin-1')
            content = post.content if read_full_content else None
            logging.info(f"Leitura ({'metadata e conteúdo' if read_full_content else 'apenas metadata'}) bem-sucedida de {note_path.name} com latin-1.")
            return post.metadata, content
        except Exception as e_alt:
            logging.error(f"Erro ao ler {note_path} mesmo com codificação alternativa: {e_alt}")
            return None, None
    except frontmatter.YAMLParseError as e_yaml:
         logging.error(f"Erro ao parsear o frontmatter YAML no arquivo {note_path}: {e_yaml}")
         return None, None
    except Exception as e:
        logging.error(f"Erro inesperado ao ler ou parsear a nota {note_path}: {e}")
        return None, None


# --- Funções de IA ---

def get_summary_from_gemini(genai_client: genai.Client, note_titles: list[str]) -> str | None:
    """Chama a API Gemini para gerar um resumo baseado em títulos de notas."""
    # ... (código inalterado da v19) ...
    if not genai_client:
        logging.warning("Cliente da API Gemini não inicializado. Pulando chamada de resumo.")
        return None
    if not note_titles:
        logging.warning("Nenhum título de nota fornecido para gerar resumo.")
        return None
    MAX_TITLES_FOR_SUMMARY = 100
    titles_to_send = note_titles
    if len(note_titles) > MAX_TITLES_FOR_SUMMARY:
         logging.warning(f"Muitos títulos ({len(note_titles)}), limitando a {MAX_TITLES_FOR_SUMMARY} para o prompt de resumo.")
         titles_to_send = note_titles[:MAX_TITLES_FOR_SUMMARY]
    prompt = f"""
    Analise a lista de títulos de notas de um vault Obsidian fornecida abaixo.
    Gere um resumo conciso em markdown identificando os principais temas, clusters de tópicos ou áreas de foco que emergem desta lista.
    O objetivo é criar um índice ou visão geral de alto nível do conteúdo do vault baseado apenas nos títulos.

    **Títulos das Notas:**
    {chr(10).join(f'- {title}' for title in titles_to_send)}

    **Instruções:**
    1. Leia todos os títulos.
    2. Identifique temas recorrentes ou grupos lógicos (ex: "Projetos", "Estudos de IA", "Finanças Pessoais", "Ideias Aleatórias").
    3. Escreva um resumo em formato markdown, usando cabeçalhos (##) para os temas principais e listas (-) para notas relacionadas ou observações. **NÃO inclua blocos de código (```) na sua resposta.**
    4. Seja conciso e direto ao ponto.

    **Resumo Gerado:**
    """ # Adicionada instrução para NÃO incluir ```
    contents = [prompt]
    safety_settings_types = [
        types.SafetySetting(category='HARM_CATEGORY_HARASSMENT', threshold='BLOCK_MEDIUM_AND_ABOVE'),
        types.SafetySetting(category='HARM_CATEGORY_HATE_SPEECH', threshold='BLOCK_MEDIUM_AND_ABOVE'),
        types.SafetySetting(category='HARM_CATEGORY_SEXUALLY_EXPLICIT', threshold='BLOCK_MEDIUM_AND_ABOVE'),
        types.SafetySetting(category='HARM_CATEGORY_DANGEROUS_CONTENT', threshold='BLOCK_MEDIUM_AND_ABOVE'),
    ]
    generation_config = types.GenerateContentConfig(safety_settings=safety_settings_types)
    try:
        logging.info(f"Chamando a API Gemini ({GEMINI_MODEL_NAME}) para gerar resumo...")
        response = genai_client.models.generate_content(
            model=GEMINI_MODEL_NAME,
            contents=contents,
            config=generation_config
        )
        logging.info("Resumo recebido da API Gemini.")
        if response.text:
             return response.text
        else:
             logging.warning("Resposta da API Gemini para resumo não contém texto. Verifique o prompt feedback:")
             if hasattr(response, 'prompt_feedback'):
                 logging.warning(f"{response.prompt_feedback}")
             else:
                 logging.warning("Prompt feedback não disponível na resposta.")
             return None
    except Exception as e:
        logging.error(f"Erro ao chamar a API Gemini para gerar resumo: {e}")
        return None


# --- Função para escrever resumo em novo arquivo ---
def write_summary_to_new_note(summary_text: str, folder_path: pathlib.Path, filename_prefix: str):
    """
    Cria um novo arquivo .md na pasta especificada e escreve o resumo nele,
    removendo possíveis cercas de bloco de código da resposta da IA.
    """
    try:
        # --- NOVO: Limpeza da resposta da IA ---
        cleaned_summary = summary_text.strip() # Remove espaços em branco extras no início/fim
        lines = cleaned_summary.splitlines()

        # Remove a primeira linha se for ``` ou ``` markdown (ou similar)
        if lines and lines[0].strip().startswith("```"):
            logging.info("Removendo cerca de bloco de código inicial da resposta da IA.")
            lines = lines[1:]
            cleaned_summary = "\n".join(lines) # Reconstitui sem a primeira linha

        # Remove a última linha se for ```
        # Precisa verificar novamente 'lines' caso a primeira linha tenha sido removida
        if lines and lines[-1].strip() == "```":
            logging.info("Removendo cerca de bloco de código final da resposta da IA.")
            lines = lines[:-1]
            cleaned_summary = "\n".join(lines).strip() # Reconstitui e remove espaços finais

        # -----------------------------------------

        folder_path.mkdir(parents=True, exist_ok=True)
        logging.info(f"Pasta de destino para resumo verificada/criada: {folder_path}")
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"{filename_prefix}{timestamp}.md"
        file_path = folder_path / filename

        # Escreve o conteúdo limpo no novo arquivo
        file_path.write_text(cleaned_summary, encoding='utf-8')
        logging.info(f"Resumo (limpo) escrito com sucesso em: {file_path}")

    except Exception as e:
        logging.error(f"Erro ao criar ou escrever no arquivo de resumo {filename}: {e}")


# --- Lógica Principal ---

def main():
    """
    Função principal do script - Foco em criar nota de resumo.
    """
    logging.info("Iniciando script - MODO: Criação de Nota de Resumo.")

    if not VAULT_PATH.is_dir():
        logging.critical(f"Caminho do Vault inválido ou inacessível: '{VAULT_PATH}'.")
        return

    if not client:
         logging.critical("Cliente da API Gemini não inicializado. Script não pode continuar.")
         return

    # --- Encontrar e Ler Notas ---
    all_notes_paths = find_notes(VAULT_PATH)
    if not all_notes_paths:
        logging.warning("Nenhuma nota encontrada no vault para resumir.")
        logging.info("Script concluído.")
        return

    notes_metadata = {}
    note_titles = []
    logging.info(f"Iniciando leitura de metadados de {len(all_notes_paths)} notas...")
    # ... (loop de leitura inalterado da v19) ...
    successful_reads = 0
    failed_reads = 0
    for note_path in all_notes_paths:
        metadata, _ = read_note_content(note_path, read_full_content=False)
        if metadata is not None:
            try:
                relative_path_str = str(note_path.relative_to(VAULT_PATH)).replace('\\', '/')
                notes_metadata[relative_path_str] = {'metadata': metadata, 'full_path': note_path}
                note_titles.append(relative_path_str)
                successful_reads += 1
            except ValueError as ve:
                 logging.error(f"Erro ao calcular caminho relativo para {note_path}: {ve}")
                 failed_reads += 1
            except Exception as e:
                 logging.error(f"Erro inesperado ao processar nota {note_path}: {e}")
                 failed_reads += 1
        else:
            logging.warning(f"Falha ao ler metadados da nota: {note_path.name}")
            failed_reads += 1

    logging.info(f"Leitura de metadados concluída: {successful_reads} notas lidas, {failed_reads} falhas.")


    if not note_titles:
        logging.warning("Nenhum título de nota disponível para gerar resumo.")
        logging.info("Script concluído.")
        return

    # --- Geração de Resumo pela IA ---
    logging.info(f"Solicitando resumo para {len(note_titles)} títulos de notas...")
    summary_text = get_summary_from_gemini(client, note_titles)

    if summary_text:
        logging.info("\n--- Resumo Gerado pela API Gemini (Bruto) ---")
        # Mostra a resposta bruta para depuração, caso a limpeza falhe
        # for line in summary_text.splitlines():
        #     logging.info(line)
        logging.info(summary_text[:500] + "..." if len(summary_text) > 500 else summary_text) # Log truncado
        logging.info("-------------------------------------------\n")

        # --- Escrita do Resumo em Novo Arquivo (com limpeza) ---
        summary_folder_full_path = VAULT_PATH / SUMMARY_FOLDER_RELATIVE_PATH
        write_summary_to_new_note(summary_text, summary_folder_full_path, SUMMARY_FILENAME_PREFIX)

    else:
        logging.warning("Não foi possível gerar o resumo.")

    logging.info("Script concluído.")

# --- Execução ---
if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        logging.critical(f"Erro fatal não tratado na execução principal: {e}", exc_info=True)


```