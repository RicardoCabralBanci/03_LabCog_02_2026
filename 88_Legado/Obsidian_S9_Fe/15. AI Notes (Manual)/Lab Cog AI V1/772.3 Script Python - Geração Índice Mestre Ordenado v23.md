```
# -*- coding: utf-8 -*-
import os
import pathlib
import re
import frontmatter
import logging
import shutil
from google import genai
from google.genai import types
import time
from datetime import datetime

# --- Configuração Inicial ---
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
VAULT_PATH = pathlib.Path(r"C:\Lab_Cognitivo_Script\Obsidian_S9_Fe")
NOTE_EXTENSIONS = ['.md']
CREATE_BACKUP = True # Relevante para futuras modificações de notas existentes
# --- Configuração da Pasta e Arquivo de Índice ---
INDEX_FOLDER_RELATIVE_PATH = "13. AI Notes" # Pasta para o índice
INDEX_FILENAME = "1. Indice Mestre por Data Criação.md" # Nome do arquivo índice

# --- Configuração da Nota de Orientação (Prompt Externo) ---
GUIDANCE_NOTE_RELATIVE_PATH = "Config/Instrucoes_Link_IA.md" # Não usado nesta versão

# --- Configuração da API Gemini ---
# ####################################################################
# ### ATENÇÃO! API KEY HARDCODED ABAIXO!                           ###
# ### ... (Avisos de segurança mantidos) ...                       ###
# ####################################################################
HARDCODED_API_KEY = "AIzaSyDWG30FYAUc6XyVCv71vnR50pjWF-aN7i8" # <--- CHAVE INSERIDA DIRETAMENTE!

# Instancia o cliente da API
client: genai.Client | None = None
# ... (Lógica de inicialização do cliente mantida) ...
if not HARDCODED_API_KEY or HARDCODED_API_KEY == "SUA_CHAVE_API_REAL_AQUI":
     logging.error("### ERRO CRÍTICO: API Key está vazia ou não foi substituída! ###")
     client = None
else:
    try:
        client = genai.Client(api_key=HARDCODED_API_KEY)
        client.models.list() # Verifica a autenticação
        logging.info("Cliente da API Gemini inicializado com sucesso (usando chave HARDCODED - NÃO SEGURO!).")
    except Exception as e:
        logging.error(f"Erro CRÍTICO ao inicializar o cliente da API Gemini com a chave fornecida: {e}.")
        client = None

# Modelo Gemini a ser usado - Não usado nesta versão
# GEMINI_MODEL_NAME = "models/gemini-1.5-pro"

# --- Funções Auxiliares ---

def find_notes_with_creation_time(vault_dir: pathlib.Path) -> list[tuple[pathlib.Path, float]]:
    """
    Encontra todos os arquivos de nota únicos no vault, ignorando pastas específicas,
    e retorna uma lista de tuplas (caminho_completo, timestamp_criacao).
    """
    # ... (código inalterado da v22) ...
    logging.info(f"Procurando por notas e suas datas de criação em: {vault_dir}")
    if not vault_dir.is_dir():
        logging.error(f"O caminho especificado não é um diretório válido: {vault_dir}")
        return []
    note_files_with_ctime = []
    processed_inodes = set()
    ignore_paths = []
    if INDEX_FOLDER_RELATIVE_PATH:
        ignore_paths.append((vault_dir / INDEX_FOLDER_RELATIVE_PATH).resolve())
    if GUIDANCE_NOTE_RELATIVE_PATH:
        ignore_paths.append((vault_dir / GUIDANCE_NOTE_RELATIVE_PATH).resolve())

    for item in vault_dir.rglob('*'):
        try:
            resolved_item = item.resolve()
            is_ignored = False
            for ignored_path in ignore_paths:
                try:
                    if resolved_item == ignored_path or ignored_path in resolved_item.parents:
                        is_ignored = True
                        break
                except Exception as e_rel:
                     logging.debug(f"Erro ao checar parentesco de ignore path para {item}: {e_rel}")
            if is_ignored:
                 continue

            if item.is_file() and item.suffix.lower() in NOTE_EXTENSIONS:
                try:
                    stats = item.stat()
                    inode = stats.st_ino
                    if inode not in processed_inodes:
                        try:
                            creation_time = stats.st_birthtime
                            logging.debug(f"Usando st_birthtime para {item.name}")
                        except AttributeError:
                            creation_time = stats.st_ctime
                            logging.debug(f"st_birthtime não disponível, usando st_ctime para {item.name}")
                        note_files_with_ctime.append((item, creation_time))
                        processed_inodes.add(inode)
                    else:
                        logging.debug(f"Arquivo já processado (possivelmente link simbólico): {item}")
                except FileNotFoundError:
                     logging.warning(f"Arquivo desapareceu antes do stat(): {item}")
                except OSError as e_stat:
                    logging.warning(f"Não foi possível obter stat() do arquivo {item}: {e_stat}")
        except OSError as e:
            logging.warning(f"Não foi possível acessar o item {item}: {e}")
        except Exception as e:
            logging.error(f"Erro inesperado ao processar o item {item}: {e}")

    logging.info(f"Encontradas {len(note_files_with_ctime)} notas únicas para indexação.")
    note_files_with_ctime.sort(key=lambda x: x[1])
    logging.info("Notas ordenadas por data de criação.")
    return note_files_with_ctime

# --- Função para escrever Índice Mestre ---
def write_master_index(sorted_notes: list[tuple[pathlib.Path, float]], index_folder_path: pathlib.Path, index_filename: str, vault_root: pathlib.Path):
    """
    Cria/sobrescreve o arquivo de Índice Mestre com links ordenados.

    Args:
        sorted_notes: Lista de tuplas (Path, ctime) das notas, já ordenada.
        index_folder_path: Caminho completo (Path) para a pasta do índice.
        index_filename: Nome do arquivo para o índice (ex: "1. Indice.md").
        vault_root: Caminho raiz do vault (Path) para calcular caminhos relativos.
    """
    try:
        index_folder_path.mkdir(parents=True, exist_ok=True)
        logging.info(f"Pasta de destino para índice verificada/criada: {index_folder_path}")
        index_file_path = index_folder_path / index_filename
        logging.info(f"Gerando conteúdo para o Índice Mestre: {index_file_path}")

        # Conteúdo inicial do arquivo
        index_content = f"# Índice Mestre (Ordenado por Data de Criação)\n\n"
        index_content += f"*Gerado em: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}*\n\n"
        count = 0

        # Itera pelas notas ordenadas para criar as linhas do índice
        for note_path, creation_time in sorted_notes:
            try:
                relative_path = note_path.relative_to(vault_root)
                link_path = str(relative_path.with_suffix('')).replace('\\', '/')
                creation_date_str = datetime.fromtimestamp(creation_time).strftime('%Y-%m-%d')

                # --- ALTERAÇÃO AQUI ---
                # Formato: Link primeiro, depois a data
                index_content += f"- [[{link_path}]] - {creation_date_str}\n"
                # Formato anterior: index_content += f"- {creation_date_str} - [[{link_path}]]\n"
                # --- FIM DA ALTERAÇÃO ---
                count += 1
            except ValueError as ve:
                logging.error(f"  Erro ao processar link para {note_path}: {ve}")
            except Exception as e_link:
                 logging.error(f"  Erro inesperado ao formatar link para {note_path}: {e_link}")

        # Escreve o conteúdo no arquivo de índice (sobrescreve)
        index_file_path.write_text(index_content, encoding='utf-8')
        logging.info(f"Índice Mestre com {count} links escrito com sucesso em: {index_file_path}")

    except Exception as e:
        logging.error(f"Erro ao criar ou escrever no arquivo de Índice Mestre {index_filename}: {e}")


# --- Lógica Principal ---

def main():
    """
    Função principal do script - Foco em criar Índice Mestre.
    """
    logging.info("Iniciando script - MODO: Criação de Índice Mestre.")

    if not VAULT_PATH.is_dir():
        logging.critical(f"Caminho do Vault inválido ou inacessível: '{VAULT_PATH}'.")
        return

    if not client:
         logging.warning("Cliente da API Gemini não inicializado (não necessário para Índice Mestre).")

    sorted_notes_with_ctime = find_notes_with_creation_time(VAULT_PATH)

    if not sorted_notes_with_ctime:
        logging.warning("Nenhuma nota encontrada no vault para indexar.")
        logging.info("Script concluído.")
        return

    index_folder_full_path = VAULT_PATH / INDEX_FOLDER_RELATIVE_PATH
    write_master_index(sorted_notes_with_ctime, index_folder_full_path, INDEX_FILENAME, VAULT_PATH)

    logging.info("Funcionalidades de Sumarização e Sugestão de Links desativadas nesta execução.")
    logging.info("Script concluído.")

# --- Execução ---
if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        logging.critical(f"Erro fatal não tratado na execução principal: {e}", exc_info=True)


```