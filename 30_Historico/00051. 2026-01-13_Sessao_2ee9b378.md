# üìì Sess√£o 00051 - 2026-01-13T11:55:57.877Z
**ID da Sess√£o**: `2ee9b378-43f6-4492-9873-e0ec13cc4aa5`

---

## üë§ USER - 2026-01-13T11:55:57.877Z

@04. Arquivos e Projetos\04. Versoes_Projeto\02. Hibrido_CSharp\02. Recursos_Legados\Config_BA\01. VBA_MODULES_SCRIPTS\0100. Script_BTR.md   explique para mim como funciona o script do caminha acaima
--- Content from referenced files ---
Content from @04. Arquivos e Projetos\04. Versoes_Projeto\02. Hibrido_CSharp\02. Recursos_Legados\Config_BA\01. VBA_MODULES_SCRIPTS\0100. Script_BTR.md:
```vba
Attribute VB_Name = "BTR"
Option Explicit
Const template = "\manual.dotm"
Private Function createDoc(ByVal Path As String) As Word.Document
    
    Dim objword As Word.Application, objDoc As Word.Document, dlgSaveAs As FileDialog
    
    Set objword = New Word.Application
    Set objDoc = objword.Documents.Add
    Set dlgSaveAs = objword.FileDialog(msoFileDialogSaveAs)
    
    With dlgSaveAs
    .FilterIndex = 16: .InitialFileName = Path '16=.docx
    End With

    If Not dlgSaveAs.Show Then
        objDoc.Close: objword.Quit
        Set objDoc = Nothing
        Application.Visible = True: Application.ScreenUpdating = True: Application.Calculation = xlCalculationAutomatic: Application.EnableEvents = True
        Exit Function
    End If
    
    objDoc.SaveAs2 (dlgSaveAs.SelectedItems(1))
    
    Set createDoc = objDoc

End Function

Sub Manual(Optional byDummy As Byte)

On Error GoTo CloseEverything
'On Error GoTo 0

    'Definitions
    Dim objword As Word.Application
    Dim objDoc As Word.Document, objTempDoc As Word.Document
    Dim objSection As Word.Section
    Dim objTOC As Word.TableOfContents, objTOF As Word.TableOfFigures
    Dim templatepath As String, fileobjTempDoc As String, Path As String, file As String
    Dim docrange As Word.Range
    Dim i As Integer, lp As Integer
    
    'Just to pop up later
    Application.Visible = False: Application.ScreenUpdating = False: Application.Calculation = xlCalculationManual: Application.EnableEvents = False
    
    'File name
    Path = ActiveWorkbook.Path & "\"
    If Planilha3.Range("B7") = "Yes" Then
    file = Path & "BA_" & Info.Projeto & "_IHM_PT_" & Info.Revisao
    Else: file = Path & "BA_" & Info.Projeto & "_Innoline_PT_" & Info.Revisao: End If
    
    'Create new doc
    Set objDoc = createDoc(file)
    
    'Check if ok, close if error
    If objDoc Is Nothing Then Exit Sub
    
    'Set application
    Set objword = objDoc.Application
    objword.Visible = False
    
    'Set template
    templatepath = "V:\Abteilungen\SaoPaulo\PQK-M\Extern\Config_BA" & template
    If templatepath = vbNullString Then
    templatepath = ThisWorkbook.Path & template: End If
    If Dir(templatepath) <> vbNullString Then
        objDoc.AttachedTemplate = templatepath: objDoc.CopyStylesFromTemplate templatepath: End If
    
    'Rows loop
    For i = 5 To 138
        
        'IHM update Case Conditional
        If Planilha3.Range("B7") = "Yes" Then   'IHM yes + 1 row
            Select Case i
            Case 8 To 61, 94 To 137 'IHM yes + 1 to before Chapter 5 start, After Chapter 5 end to "Contra capa" -1
                'Do nothing
            Case Else: GoTo Generate: End Select: End If
        
        If Planilha3.Range("B7") = "No" Then
        GoTo Generate: End If
        
        GoTo LoopEnd
        
Generate:
        'Loop conditional
        If Planilha3.Range("B" & i) = "Yes" Then
    
            'Set files
            fileobjTempDoc = Planilha3.Range("C" & i).Value 'If B Yes and C empty code breaks, can activate on error resume next to ignore
            Set objTempDoc = objword.Documents.Open(Filename:=fileobjTempDoc, ReadOnly:=True, AddToRecentFiles:=False)
    
            'Set Headers and Footers
            Set objSection = objDoc.Range.Sections.Last
            With objSection
                .Headers(wdHeaderFooterPrimary).LinkToPrevious = False: .Footers(wdHeaderFooterEvenPages).LinkToPrevious = False
            End With
    
            'Copy properties & Setup
            Call CopyProperty(objTempDoc, objDoc)
            Call CopySetup(objTempDoc, objSection)
    
            'Insert file
            Set docrange = objDoc.Range
            docrange.Collapse wdCollapseEnd: docrange.InsertFile Filename:=objTempDoc.FullName
           
            'Pagebreak
            Set docrange = objTempDoc.Content
            docrange.Find.Execute findtext:="Quebra de pgina"
            If docrange.Find.Found = False Then
                Set docrange = objDoc.Range
                docrange.Collapse wdCollapseEnd: docrange.InsertBreak Type:=wdSectionBreakNextPage: End If
        
        'Close Source doc
        objTempDoc.Close wdDoNotSaveChanges
        
        'End conditional
        End If
               
        
        'Clear doc object
        Set objTempDoc = Nothing
        
LoopEnd:
    'End loop
    Next i
    
    UpdateCustomProperties objDoc
             
    'Update tables
        Call TableSub(objDoc, objword)
        
    'Update page and date
    With objDoc
        For i = 3 To .Sections.Count - 1
            .Sections(i).Headers(wdHeaderFooterPrimary).PageNumbers.IncludeChapterNumber = False
            .Sections(i).Footers(wdHeaderFooterPrimary).Range.Fields.Update
        Next
    End With
    
    ' Update all fields and table of contents
    For Each objTOC In objDoc.TablesOfContents: objTOC.Update: Next: objDoc.Fields.Update
    
    'Update Image subs
    For Each objTOF In objDoc.TablesOfFigures: objTOF.Update: Next
    
    'Keep Chapter start on odd page number
    Dim pr As Word.Paragraph

    For Each objSection In objDoc.Range.Sections
    Wait (0.2)
        Set pr = objSection.Range.Paragraphs.first
        If pr.Style = "Ttulo 1" Then
            i = pr.Range.Information(wdActiveEndPageNumber)
            If i Mod 2 = 0 Then
                Set docrange = pr.Range
                docrange.Collapse wdCollapseStart: docrange.InsertBreak wdSectionBreakNextPage
            End If
        End If
    Next
    
    Wait (1)
    
    'Contra capa handling
    With objDoc
        i = .Sections.Count - 1
        .Sections(i).Range.Paragraphs.Last.Range.Collapse wdCollapseEnd
        lp = .Sections(i).Range.Paragraphs.Last.Range.Information(wdActiveEndPageNumber)
        If lp Mod 2 <> 0 Then
            .Sections(i).Range.Paragraphs.Last.Range.InsertBreak wdSectionBreakNextPage
        End If
    End With
    
    Wait (1)
    
    'Blank page left intentionally
    With objDoc
        For i = 4 To .Sections.Count - 1
            Set docrange = .Sections(i).Range
            If Len(docrange.Text) <= 1 Then
                docrange.Style = "normal": docrange.Collapse wdCollapseStart: .AttachedTemplate.BuildingBlockEntries("BlankPage").Insert docrange
            End If
        Next
    End With
    
    ' Update all fields and table of contents
    For Each objTOC In objDoc.TablesOfContents: objTOC.Update: Next: objDoc.Fields.Update
    
    ' Finalize changes
    If Not objTempDoc Is Nothing Then objTempDoc.Close
        
    'Replace prep
    With Planilha2
    .Range("E2").ClearContents: .Range("D4:G20").ClearContents: .Range("E2") = objDoc.FullName
    End With
    
    'Choose your fate
    Dim answer As Integer
    
    objword.ActiveWindow.Selection.GoTo wdGoToPage, wdGoToFirst: objDoc.Save
    
    Application.Visible = True: Application.Calculation = xlCalculationAutomatic: Application.EnableEvents = True
        
    answer = MsgBox("Manual gerado com sucesso, deseja revisar agora?", vbQuestion + vbYesNo + vbDefaultButton2, "Finalizado com sucesso")
    
    If answer = vbYes Then
        
    objword.Visible = True: objword.Activate: objword.WindowState = wdWindowStateMaximize
    
    On Error GoTo exitsub
    
    Else: objDoc.Close
    Set objDoc = Nothing
    For Each objDoc In objword.Documents: objDoc.Close wdDoNotSaveChanges: Next: objword.Quit
            
    'If close and wait revision
    MsgBox "Manual gerado na pasta selecionada, favor revisar assim que possvel!", vbExclamation + vbOKOnly, "Reviso pendente": End If
        
    On Error GoTo exitsub
        
    Exit Sub
    
'Uppon error quit
CloseEverything:
    Application.Visible = True: Application.ScreenUpdating = True: Application.Calculation = xlCalculationAutomatic: Application.EnableEvents = True
    If Not objword Is Nothing Then objword.Visible = True
    If Not objTempDoc Is Nothing Then objTempDoc.Close
    MsgBox "Infelizmente um erro ocorreu, tente novamente ou entre em contato com o responsvel.", vbCritical + vbOKOnly, "Erro  :("
    On Error GoTo 0
    Exit Sub
    
'Blank VBA error handler
exitsub:
    
End Sub

Private Sub CopySetup(ByRef Source As Word.Document, ByRef Dest As Variant)
' COPYSETUP: Copies page settings from source to destination
    
    If TypeName(Dest) = "Document" Then
        CopyPageSetup Source.Sections.first.PageSetup, Dest.Sections.Last.PageSetup
    ElseIf TypeName(Dest) = "Section" Then
        CopyPageSetup Source.Sections.first.PageSetup, Dest.PageSetup
    Else: MsgBox "Invalid Destination Parameter", vbExclamation: End If

End Sub

Private Sub CopyPageSetup(ByRef Source As Word.PageSetup, ByRef Dest As Word.PageSetup)
' COPYPAGESETUP: Copies page settings from source to dest
With Dest
    .LineNumbering.Active = Source.LineNumbering.Active: .Orientation = Source.Orientation: .TopMargin = Source.TopMargin
    .BottomMargin = Source.BottomMargin: .LeftMargin = Source.LeftMargin: .RightMargin = Source.RightMargin: .Gutter = Source.Gutter
    .HeaderDistance = Source.HeaderDistance: .FooterDistance = Source.FooterDistance: .PageWidth = Source.PageWidth: .PageHeight = Source.PageHeight
    .FirstPageTray = Source.FirstPageTray: .OtherPagesTray = Source.OtherPagesTray: .OddAndEvenPagesHeaderFooter = Source.OddAndEvenPagesHeaderFooter
    .DifferentFirstPageHeaderFooter = Source.DifferentFirstPageHeaderFooter: .SuppressEndnotes = Source.SuppressEndnotes: .MirrorMargins = Source.MirrorMargins
End With
    
End Sub

Private Sub CopyProperty(ByRef Source As Word.Document, ByRef Dest As Word.Document)
    Dim srcProperty As Variant
    
    For Each srcProperty In Source.CustomDocumentProperties
        If CDPExists(srcProperty.Name, Dest) Then GoTo Continue
        Dest.CustomDocumentProperties.Add Name:=srcProperty.Name, LinkToContent:=False, Value:=srcProperty.Value, Type:=msoPropertyTypeString
Continue:
    Next

End Sub

Private Function CDPExists(ByVal CDPName As String, ByRef objDoc As Word.Document) As Boolean
    Dim objCDP As Variant
    For Each objCDP In objDoc.CustomDocumentProperties
        If objCDP.Name = CDPName Then
            CDPExists = True
            Exit Function
        End If
    Next
    
    CDPExists = False
End Function

Private Sub UpdateCDP(ByVal CDPName As String, ByRef objDoc As Word.Document, ByVal Value As String)

If Not CDPExists(CDPName, objDoc) Then Exit Sub

objDoc.CustomDocumentProperties(CDPName) = Value

End Sub

Private Sub UpdateCustomProperties(ByRef objDoc As Word.Document)
    
    If Planilha2.Cells(23, 1).Value <> vbNullString Then
    UpdateCDP "MachineType", objDoc, "DTR"
    Else: UpdateCDP "MachineType", objDoc, "BTR": End If
    UpdateCDP "MachineNumber", objDoc, Info.SapNr.Value: UpdateCDP "Order", objDoc, Info.Projeto.Value
    UpdateCDP "Revision", objDoc, Info.Revisao.Value: UpdateCDP "MachineYear", objDoc, Info.Ano.Value
End Sub

Private Sub TableSub(ByRef objDoc As Word.Document, objword As Word.Application)

Dim erng As Excel.Range
Dim oRng As Word.Range, nRng As Word.Range
Dim oDoc As Word.Document
Dim ntable As Word.table, oTable As Word.table
Dim i As Integer

On Error GoTo hand

    Set oDoc = objword.Documents.Add
    
    For Each oTable In objDoc.Tables
            
            'Tables sub
            If oTable.Title = "Componentes integrados" Then
            
                Set erng = Planilha4.Range("B2:D" & Planilha4.Range("B" & Rows.Count).End(xlUp).Row)
                erng.Copy
                Wait (1)
                                
                'Formatting
                Set nRng = oDoc.Range
                nRng.PasteExcelTable False, False, False
                
                Application.CutCopyMode = False
                
                Set ntable = oDoc.Tables(1)
                
                Call format(ntable, objword)
                Call format2(ntable, objword)
                
                'Paste formated table
                Set nRng = ntable.Range
                nRng.Copy
                                                
                Set oRng = oTable.Range
                oTable.Delete
                
                Wait (1)

                oRng.Paste: nRng.Delete
                
                'To get another table
                GoTo Handling
                            
            End If
            
            If oTable.Title = "reas e segmentos" Then
                Set erng = Planilha8.Range("B2:D" & Planilha8.Range("D" & Rows.Count).End(xlUp).Row)
                erng.Copy
                Wait (1)
                                
                'Formatting
                Set nRng = oDoc.Range
                nRng.PasteExcelTable False, False, False
                
                Application.CutCopyMode = False
                
                Set ntable = oDoc.Tables(1)
                
                Call format(ntable, objword)
                
                With ntable.Range
                For i = 1 To .Cells.Count
                    If .Cells(i).RowIndex < 3 Then
                        .Cells(i).Range.Font.Bold = True
                        .Cells(i).VerticalAlignment = wdCellAlignVerticalCenter
                        .Cells(i).Range.ParagraphFormat.Alignment = wdAlignParagraphCenter
                    End If
                Next
                End With
              
                
                'Paste formated table
                Set nRng = ntable.Range
                nRng.Copy
                                                
                Set oRng = oTable.Range
                oTable.Delete
                
                Wait (1)

                oRng.Paste: nRng.Delete
                
                'To get another table
                GoTo Handling
                            
            End If
            
            If oTable.Title = "Dispositivos de comando" Then
                Set erng = Planilha9.Range("B3:D" & Planilha9.Range("B" & Rows.Count).End(xlUp).Row)
                erng.Copy
                Wait (1)
                                
                'Formatting
                Set nRng = oDoc.Range
                nRng.PasteExcelTable False, False, False
                
                Application.CutCopyMode = False
                
                Set ntable = oDoc.Tables(1)
                
                Call format(ntable, objword)
                        
                With ntable.Rows(1)
                    .HeadingFormat = True
                    With .Range
                        .Font.Size = "10": .Font.Bold = True: .ParagraphFormat.Alignment = wdAlignParagraphCenter
                    End With
                End With
                
                'Paste formated table
                Set nRng = ntable.Range
                nRng.Copy
                                                
                Set oRng = oTable.Range
                oTable.Delete
                
                Wait (1)

                oRng.Paste: nRng.Delete
                
                'To get another table
                GoTo Handling
            
            End If
            
            If oTable.Title = "Dispositivos de aviso" Then
                Set erng = Planilha10.Range("B3:D" & Planilha10.Range("B" & Rows.Count).End(xlUp).Row)
                erng.Copy
                Wait (1)
                                
                'Formatting
                Set nRng = oDoc.Range
                nRng.PasteExcelTable False, False, False
                
                Application.CutCopyMode = False
                
                Set ntable = oDoc.Tables(1)
                
                Call format(ntable, objword)
                        
                With ntable.Rows(1)
                    .HeadingFormat = True
                    With .Range
                        .Font.Size = "10": .Font.Bold = True: .ParagraphFormat.Alignment = wdAlignParagraphCenter
                    End With
                End With
                
                'Paste formated table
                Set nRng = ntable.Range
                nRng.Copy
                                                
                Set oRng = oTable.Range
                oTable.Delete
                
                Wait (1)

                oRng.Paste: nRng.Delete
                
                'To get another table
                GoTo Handling
            
            End If
            
            If oTable.Title = "Tipos de recipientes" Then
                Set erng = Planilha7.Range("B2:H" & Planilha7.Range("B" & Rows.Count).End(xlUp).Row)
                erng.Copy
                Wait (1)
                                
                'Formatting
                Set nRng = oDoc.Range
                nRng.PasteExcelTable False, False, False
                
                Application.CutCopyMode = False
                
                Set ntable = oDoc.Tables(1)
                
                Call format(ntable, objword)
                Call format2(ntable, objword)
                
                With ntable.Range
                For i = 1 To .Cells.Count
                    If .Cells(i).ColumnIndex = 1 Then
                        .Cells(i).VerticalAlignment = wdCellAlignVerticalCenter: .Cells(i).Range.ParagraphFormat.Alignment = wdAlignParagraphCenter
                    End If
                Next
                End With
                
                'Paste formated table
                Set nRng = ntable.Range
                nRng.Copy
                                                
                Set oRng = oTable.Range
                oTable.Delete
                
                Wait (1)

                oRng.Paste: nRng.Delete
                
                'To get another table
                GoTo Handling
            
            End If
        
Handling:
    Next
    
    'close doc
    oDoc.Close wdDoNotSaveChanges
    
    Exit Sub

hand:
Wait (1)
Resume
                       
End Sub

Function Wait(ByVal Seconds As Single)
    Dim CurrentTimer As Variant
    CurrentTimer = Timer
    Do While Timer < CurrentTimer + Seconds
    Loop
End Function

Sub format(ByRef ntable As Word.table, objword As Word.Application)

        With ntable
                .PreferredWidthType = wdPreferredWidthPoints: .PreferredWidth = objword.CentimetersToPoints(15): .Rows.Height = objword.CentimetersToPoints(0.75): .AutoFitBehavior (wdAutoFitWindow)
                
            With .Borders
                .InsideLineStyle = wdLineStyleSingle: .InsideLineWidth = wdLineWidth225pt: .InsideColor = wdColorWhite
                .OutsideLineStyle = wdLineStyleSingle: .OutsideLineWidth = wdLineWidth225pt: .OutsideColor = wdColorWhite
            End With
            
            With .Range
                .Style = "normal": .Font.Name = "Arial": .Font.Size = "11": .ParagraphFormat.SpaceBefore = (3): .ParagraphFormat.SpaceAfter = (3)
                .ParagraphFormat.RightIndent = objword.CentimetersToPoints(0.1): .ParagraphFormat.LeftIndent = objword.CentimetersToPoints(0.1)
                .Cells.VerticalAlignment = wdCellAlignVerticalCenter: .ParagraphFormat.Alignment = wdAlignParagraphLeft
            End With
        End With

End Sub

Sub format2(ByRef ntable As Word.table, objword As Word.Application)

    With ntable.Rows(1)
        .HeadingFormat = True
        With .Range
            .Font.Size = "10": .Font.Bold = True: .ParagraphFormat.Alignment = wdAlignParagraphCenter
        End With
    End With
    
    With ntable.Rows(2)
        .HeadingFormat = True
        With .Range
            .Font.Size = "10": .Font.Bold = True: .ParagraphFormat.Alignment = wdAlignParagraphCenter
        End With
    End With

End Sub
```
--- End of content ---

---

## ü§ñ GEMINI - 2026-01-13T11:56:25.025Z

<details>
<summary>üí≠ Ver Pensamentos</summary>

> **Delving Into the Script**: I've initiated the process by zeroing in on the user's ultimate aim: to grasp a particular VBA script. I'm now focused on dissecting the script's core function. I'm taking the initial steps by breaking down the core functionality and what it is designed to achieve in its context.

> **Deconstructing the Core Logic**: I am now focusing on the script's decision-making process. The `Manual` subroutine uses "IHM" or "Innoline" in cell B7 to set the output filename, suggesting conditional behavior based on this value. This impacts the way the word document is created, which is also based on a check on each row of the excel sheet.

> **Examining the Iterations**: I'm now zeroing in on the loop that processes the rows of the Excel sheet, which is the heart of content generation for the final document. The conditional checks and insertions, and the logic around the manual page breaks, will be key to understanding how the script assembles the final product. The calls to `CopyProperty` and `CopySetup` seem to manage the formatting, and so, are next.

> **Synthesizing the Workflow**: Now, I'm piecing together the flow. The script creates a Word document from parts. It reads settings from an Excel sheet to determine file name, template, and document sections. The core is the loop inserting files, using conditional logic and helper functions to manage formatting, metadata, and page layout.

> **Outlining the Core Elements**: I've now created a structured outline, breaking down the script's steps. I've noted the main procedures, the loop's function, and the data injection through the table updates. It seems the file assembly is tightly integrated with conditional logic and formatting via helper functions.

> **Dissecting Key Operations**: I'm now focusing on the helper functions, particularly `TableSub`. This function's role of injecting dynamic data from Excel into the Word document seems critical. Understanding how specific Excel sheets, like `Planilha4` and `Planilha8`, feed into these tables is the next critical step for complete comprehension.

</details>

Este script VBA, chamado `Script_BTR.md` (internamente o m√≥dulo chama-se `BTR`), √© um **Gerador de Manuais Automatizado** para m√°quinas do tipo "BTR". Ele atua como um "maestro", orquestrando o Microsoft Word a partir do Excel para montar um documento final completo.

Aqui est√° uma explica√ß√£o detalhada de como ele funciona, dividida por etapas l√≥gicas:

### 1. Prepara√ß√£o e Cria√ß√£o do Arquivo (`Sub Manual`)
*   **Inicializa√ß√£o:** O script come√ßa ocultando o Excel (`Application.Visible = False`) para que o processo rode em segundo plano e seja mais r√°pido.
*   **Nome do Arquivo:** Ele define o nome do manual com base em informa√ß√µes da planilha (Projeto, Revis√£o) e se a op√ß√£o "IHM" (Interface Homem-M√°quina) est√° ativa na `Planilha3`.
*   **Novo Documento:** A fun√ß√£o `createDoc` √© chamada para criar um novo documento Word e abrir uma janela de "Salvar Como" para o usu√°rio escolher onde guardar o manual.
*   **Template:** Ele tenta carregar um modelo (`manual.dotm`) de uma rede compartilhada (`V:\...`) ou da pasta local, importando estilos para garantir a formata√ß√£o correta.

### 2. O Loop de Montagem ("The Stitcher")
Esta √© a parte principal do script (o loop `For i = 5 To 138`). Ele percorre uma lista de configura√ß√£o na `Planilha3` (provavelmente uma lista de cap√≠tulos/t√≥picos).
*   **Condicional IHM:** Se a op√ß√£o "IHM" estiver ativa/inativa, ele pula ou inclui linhas espec√≠ficas do loop, personalizando o manual para a m√°quina espec√≠fica.
*   **Verifica√ß√£o "Yes":** Se a coluna B da linha atual tiver "Yes", ele executa a inser√ß√£o.
*   **Inser√ß√£o de Conte√∫do:**
    1.  L√™ o caminho de um arquivo Word parcial na coluna C.
    2.  Abre esse arquivo temporariamente (`objTempDoc`).
    3.  Copia as configura√ß√µes de p√°gina (margens, orienta√ß√£o) do arquivo parcial para a se√ß√£o atual do manual final (`CopySetup`).
    4.  **Insere o arquivo:** Cola o conte√∫do do arquivo parcial no manual final (`InsertFile`).
    5.  **Quebras de P√°gina:** Verifica se o texto inserido j√° tem uma quebra de p√°gina; se n√£o, insere uma quebra de se√ß√£o para separar o conte√∫do.

### 3. Inje√ß√£o de Dados Din√¢micos (`Sub TableSub`)
Ap√≥s montar os textos est√°ticos, o script varre o documento Word procurando por tabelas com t√≠tulos espec√≠ficos (ex: "Componentes integrados", "√Åreas e segmentos").
*   Quando encontra essas tabelas no Word, ele vai at√© planilhas espec√≠ficas do Excel (`Planilha4`, `Planilha8`, `Planilha9`, etc.), copia os dados t√©cnicos da m√°quina e cola dentro dessas tabelas no Word.
*   Aplica formata√ß√£o visual (bordas, fontes, alinhamento) usando as rotinas `format` e `format2`.

### 4. Acabamento e Polimento
*   **Metadados:** A fun√ß√£o `UpdateCustomProperties` insere propriedades no arquivo (Tipo da m√°quina, N√∫mero SAP, Revis√£o) que podem ser usadas como campos din√¢micos no Word.
*   **Numera√ß√£o e √çndices:** Atualiza os n√∫meros de p√°gina, o √çndice (TOC) e o √çndice de Figuras.
*   **Regra de P√°gina √çmpar:** Garante que novos cap√≠tulos (Estilo "T√≠tulo 1") comecem sempre em p√°ginas √≠mpares (padr√£o de impress√£o profissional), inserindo p√°ginas em branco se necess√°rio.
*   **P√°ginas em Branco:** Se houver se√ß√µes vazias, insere um bloco de constru√ß√£o "BlankPage" (provavelmente contendo o texto "P√°gina intencionalmente deixada em branco").

### 5. Finaliza√ß√£o
*   O script salva o caminho do arquivo gerado na `Planilha2`.
*   Exibe uma mensagem perguntando se o usu√°rio deseja revisar o manual agora.
*   Se "Sim", abre o Word maximizado. Se "N√£o", fecha tudo e avisa que est√° pendente de revis√£o.
*   **Tratamento de Erros:** Se algo der errado no meio, ele tem um tratador (`CloseEverything`) que reexibe o Excel e avisa o usu√°rio, evitando que o Excel fique travado e oculto na mem√≥ria.

### Resumo T√©cnico
√â um script de **Automa√ß√£o OLE (Object Linking and Embedding)**. Ele usa o Excel para controlar uma inst√¢ncia do objeto `Word.Application`, manipulando documentos, se√ß√µes, ranges e tabelas programaticamente para transformar peda√ßos soltos de texto e dados de planilha em um livro t√©cnico coeso.

---

